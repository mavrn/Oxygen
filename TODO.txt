free operators: $ ยง =>> ==>
#redo exceptions + add trycatch
#update comments
#bugtest change, macro
#rename tests

#isinstance = "is"
#binding variables
#findseq
#at assignment or atPut
#list comps ?
#spread/unpack
#add random
#add load
#default args
#make lexer operators dynamic


testcases to add
#getfield
#dicts
#kwargs
array.filter
#hashstrings
#change
#unless
#macro
#whitespace calls
#quick iter, return arrow
#repr
#all, some, none
#every
#fill
#posof -> find
#arr of
#foreach function
#select, detect
#hasKey
#hasValue
#natural language auto id
#classes

#https://www.codewars.com/kata/514a024011ea4fb54200004b/python

fn domainName url => url replace("http://", "") replace("https://", "") replace("www.", "") split: "." [0]
"http://github.com/carbonfive/raygun"  domainName 
"http://www.zombie-bites.com" domainName 
"https://www.cnet.com" domainName 
"hyphen-url.com" domainName 

['"github"', '"zombie-bites"', '"cnet"', '"hyphen-url"']


#https://www.codewars.com/kata/51b66044bce5799a7f000003

sym = ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']
num = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]

fn toRoman number =>
    let result ""
    let pointer 0
    while number =>
        div = number // num at: pointer
        number %= num at: pointer
        while div =>
            result += sym at: pointer
            div -= 1
        <<
        pointer += 1
    <<
    return result
<<

fn fromRoman roman_numeral =>
    let result 0
    roman_numeral ->
        let first_num num at(sym find: iterelem)
        let second_num num at(sym find(roman_numeral at(itercounter + 1))) if itercounter +1 != roman_numeral size else -1
        if first_num >= second_num => result += first_num
        else => result -= first_num
    <<
    return result
<<

toRoman(2541) out
fromRoman("MCCCXI") out 

["MMDXLI", "1311"]


#https://www.codewars.com/kata/54fe05c4762e2e3047000add

class Ship =>
    fn setup draft crew=>
        own draft = draft
        own crew = crew
    <<
    fn worth =>
        return own draft - 1.5*own crew > 20
    <<
<<
titanic =  Ship new(15, 10)
other_ship = Ship new(142, 36)
titanic worth out
other_ship worth out
["False", "True"]



#https://www.codewars.com/kata/5882b052bdeafec15e0000e6

class Quark =>
    fn setup color flavor =>
        own color = color
        own flavor = flavor
        own baryon_number = 1/3
    <<
    fn interact other =>
        temp_c = other color
        other color = own color
        own color = temp_c
    <<
<<
q1 = Quark new("red", "up")
color(q1)
flavor: q1
q2 = Quark new ("blue", "strange")
q2 color
q1 interact: q2
q1 color
q2 color

['"red"', '"up"', '"blue"', '"blue"', '"red"']



#https://www.codewars.com/kata/5bc7bb444be9774f100000c3

class VersionManager =>
    fn setup version =>
        own MAJOR = 0
        own MINOR = 0
        own PATCH = 1
        if version size equals 0 =>
            return
        <<
        elems = version split(".") >> x asNum
        own MAJOR = elems at: 0
        if elems size greater 0 => own MINOR = elems at: 1
        if elems size greater 1 => own PATCH = elems at: 2
    <<
    fn major =>
        own prev = [own MAJOR, own MINOR, own PATCH]
        own MAJOR += 1
        own MINOR = 0
        own PATCH = 0
    <<
    fn minor =>
        own prev = [own MAJOR, own MINOR, own PATCH]
        own MINOR += 1
        own PATCH = 0
    <<
    fn patch => 
        own prev = [own MAJOR, own MINOR, own PATCH]
        own PATCH += 1
    <<
    fn rollback =>
        own MAJOR = own prev at: 0
        own MINOR = own prev at: 1
        own PATCH = own prev at: 2
    <<
    fn release =>
        return "#own MAJOR#.#own MINOR#.#own PATCH#"
    <<
<<
game = VersionManager new ("1.1.1")
game minor
game patch
game patch
game major
game rollback
game release
    
['"1.2.2"']



#https://www.codewars.com/kata/5962bbea6878a381ed000036

class ScoreTable =>
    fn setup tableSize =>
        own tableSize = tableSize
        own scores = []
    <<
    fn update val =>
        own scores append: val
        own scores sort reverse
        if own scores size > own tableSize => own scores = own scores [0..3]
    <<
    fn reset => 
        own scores = []
    <<
<<

table = ScoreTable new: 3
table scores
table update: 10
table scores
table update: 8
table update: 12
table update: 5
table update: 10
table scores
table reset
table scores

['[]', '[10]', '[12, 10, 10]', '[]']
